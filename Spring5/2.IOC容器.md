# 2. IOC（Inversion of control）容器

## 2.1  IOC概念

1. <font color="red">**控制反转，把对象创建和对象之间的调用过程，交给Spring进行管理**</font>
2. 目的：解耦合

## 2.2 IOC底层原理

​	XML解析、工厂模式、反射

- IOC过程

```xml
<!-- 1.xml配置文件，配置创建对象 -->
<bean id="userDao" calss="com.jeffy.UserDao"></bean>
```

```java
// 2.有service类和dao类，创建工厂类
class UserFactory{
    public static UserDao getDao(){
        // 1.xml解析
        String classValue = "com.jeffy.UserDao"; // class属性值
        // 2. 通过反射创建对象
        Class clazz = Class.getName(classValue);
        return (UserDao)class.newInstance();
    }
}
```

## 2.2 IOC接口（BeanFactory）

- IOC的思想基于IOC容器完成，<font color="red">**OC容器底层就是对象工厂**</font>

- Spring提供IOC容器实现的两种方式（两个接口）
  - BeanFactory: IOC容器的最基本的实现，是Spring内部使用的接口，一般不提供给开发人员使用。

    加载配置文件时候不会创建对象，只有在获取对象（使用）的时候才会创建

  - ApplicationContext: BeanFactory接口的子接口，提供了更多、更强大的功能，一般由开发人员使用

    加载配置文件时候就会把配置文件对象进行创建

​		**将耗时耗资源的过程在启动时完成**

- ApplicationContext接口实现类
  - FileSystemXmlApplicationContext -- 盘符路径
  - ClassPathXmlApplicationContext -- 类路径

## 2.3 IOC操作Bean管理（概念）

- Bean管理
  - Spring创建对象
  - Spring注入属性
- Bean管理操作方式
  - 基于xml配置文件方式实现
  - 基于注解方式实现

## 2.4 IOC操作Bean管理（基于xml）

### 2.4.1 基于xml方式创建对象

- 在Spring配置文件中使用Bean标签，标签里面添加对应属性，就可以实现对象创建。

```xml
<bean id="userDao" calss="com.jeffy.UserDao"></bean>
```

- Bean标签常用属性
  1. id: 对象标识
  2. class:  类的全路径（包类路径）
  3. name:  和id相同，可以包含特殊符号（不常用）
- 创建对象时，默认执行无参构造方法完成对象的创建

### 2.4.2 基于xml方式注入属性

- DI：依赖注入，就是注入属性
  
- 使用set方法注入
  
  - 使用无参构造方法创建对象，通过set方法（property）给属性赋值
  
    ```xml
     <!-- 2.通过set方法注入 -->
    <bean id="person" class="pers.learn.spring5.Person">
        <!-- property: name=属性名 value=属性值 -->
        <property name="name" value="王二"/>
        <property name="age" value="22"/>
    </bean>
    ```
  
- 使用有参构造方法注入
  
  - 通过有参构造方法传递参数创建对象并赋值
  
    ```xml
    <!-- 3.通过有参构造方法注入 -->
    <bean id="orders" class="pers.learn.spring5.Orders">
    	<!-- 通过name赋值 -->
        <constructor-arg name="oname" value="computer"/>
        <constructor-arg name="address" value="China"/>
    </bean>
    ```
  
- p命名空间注入 --  简化set方法注入（不常用） 
  
    ```xml
    <!-- 添加p名称约束在配置空间中 -->
    xmlns:p="http://www.springframework.org/schema/p"
        
    <bean id="ordersP" class="pers.learn.spring5.Orders" p:oname="ppp" p:address="China"/>
  ```
  
- c命名空间注入 -- 简化构造方法注入
  
    ```xml
    <!-- 添加p名称约束在配置空间中 -->
    xmlns:c="http://www.springframework.org/schema/c"
        
    <bean id="ordersC" class="pers.learn.spring5.Orders" c:oname="ccc" c:address="China"/>
    ```
    
- 注入空值

  ```xml
   <!-- 注入空值 -->
  <property name="oname">
      <null/>
  </property>
  ```

- 注入特殊符号

  <![CDATA[带有特殊符号的字符串]]>

  ```xml
  <!-- 注入特殊符号 -->
  <bean id="orderS" class="pers.learn.spring5.Orders">
      <!-- 1.使用转义字符 -->
      <property name="oname" value="&lt;shorts&gt;"/>
      <!-- 2.使用<![CDATA[]> -->
      <property name="address" >
          <value><![CDATA[<<Beijing>>]]></value>
      </property>
  </bean>
  ```

### 2.4.2 基于xml方式注入对象

- 注入属性 -- 外部bean

  通过service层调用dao的过程称之引入外部bean
  
  1. 创建两个类：service类和dao类
  2. 在service中调用dao里面的方法
  3. 在spring配置文件中进行配置
  
- 注入属性 -- 内部bean和级联赋值

    一对多：一个部门对应多个成员

    内部bean

    ```java
    // 部门
    public class Dept {
    
        private String dname;
    
        public void setDname(String dname) { this.dname = dname; }
    
        @Override
        public String toString() { return "Dept{" + "dname='" + dname + '\'' + '}'; }
    }
    
    public class Emp {
    
        private String ename;
        private String gender;
    
        private Dept dept;
        
        // 使用类名.属性的方式注入对象时，需要通过get方法获取
        public Dept getDept() { return dept; }
    
        public void setEname(String ename) { this.ename = ename; }
    
        public void setGender(String gender) { this.gender = gender; }
    
        public void setDept(Dept dept) { this.dept = dept; }
    
        @Override
        public String toString() {
            return "Emp{" + "ename='" + ename + '\'' +
                    ", gender='" + gender + '\'' +
                    ", dept=" + dept +
                    '}';
        }
    }
    ```
    
    ```xml
    <!-- 内部部bean -->
    <bean id="emp" class="pers.learn.spring5.bean.Emp">
        <!-- 注入属性 -->
        <property name="ename" value="Licy"/>
        <property name="gender" value="女"/>
    
        <!-- 内部bean注入对象 -->
        <property name="dept">
            <bean class="pers.learn.spring5.bean.Dept">
                <property name="dname" value="财务部"/>
        </bean>
        </property>
    </bean>
    
    <bean id="emp" class="pers.learn.spring5.bean.Emp">
        <!-- 1.注入对象 -->
        <property name="dept">
            <bean class="pers.learn.spring5.bean.Dept"/>
        </property>
    
        <!-- 2.级联赋值(为已注入对象的属性赋值) -->
        <property name="dept.dname" value="技术部"/>
    </bean>
    
    ```

### 2.4.3 基于xml方式注入集合属性

- 注入数组类型的属性
- 注入List类型的属性
- 注入Map类型的属性

```java
// 1.创建类，定义数组、列表、字典、集合类型，并生成对应的set方法
public class Stu {

    // 数组类型的属性
    private String[] course;
    // List列表类型属性
    private List<String> list;
    // Map字典类型属性
    private Map<String, String> map;
    // Set集合类型属性
    private Set<String> set;

    public void setList(List<String> list) { this.list = list; }

    public void setMap(Map<String, String> map) { this.map = map; }

    public void setSet(Set<String> set) { this.set = set; }

    public void setCourse(String[] course) { this.course = course; }
}
```

-  集合里设置对象类型值

  ```xml
  <!-- 创建多个coures对象 -->
  <bean id="course1" class="pers.jeffy.spring5.collectiontype.Courses">
     <property name="cname" value="Spring5框架"/> 
  </bean>
  <bean id="course2" class="pers.jeffy.spring5.collectiontype.Courses">
      <property name="cname" value="MyBatis框架"/>
  </bean>
  
  <bean>
      <!-- 注入list集合类型，值为对象 -->
      <property name="coursesList">
          <list>
              <ref bean="course1"/>
              <ref bean="course2"/>
          </list>
      </property>
  </bean>
  ```

-  把集合注入部分取出来

  - 在Spring配置文件引入命名空间util
  - 使用util标签完成List注入提取
  - 提取List属性注入使用

  ```xml
  <?xml version="1.0" encoding="UTF-8"?>
  <!-- 在Spring配置文件引入命名空间util -->
  <beans xmlns="http://www.springframework.org/schema/beans"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns:util="http://www.springframework.org/schema/util"
         xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                              http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd">
  
      <!-- 使用util标签完成List注入提取 -->
     <util:list id="bookList">
         <value>Spring</value>
         <value>MyBatis</value>
     </util:list>
  
      <!-- 提取List属性注入使用 -->
      <bean id="book" class="pers.jeffy.spring5.collectiontype.Book">
          <property name="list" ref="bookList"/>
      </bean>
  </beans>
  ```

## 2.5 IOC操作Bean管理（FactoryBean）

- Spring有两种Bean，一种为普通的Bean，另一种叫工厂Bean（FactoryBean）

  - 普通bean（2.4中的案例）

    在Spring配置文件中定义Bean类型就是返回类型

  - 工厂Bean

    在Spring配置文件中定义的Bean类型和返回类型可以不一样

    1. 创建类，让这个类作为工程Bean，实现接口FactoryBean
    2. 实现接口里面的方法，在实现的方法中定义返回的Bean类型

  ```java
  // 定义MyBean类实现接口FactoryBean，使其返回Courses对象
  public class MyBean implements FactoryBean<Courses> {
  
      // 定义返回bean
      @Override
      public Courses getObject() throws Exception {
          Courses courses = new Courses();
          courses.setCname("asd");
          return courses;
      }
  
      @Override
      public Class<?> getObjectType() { return null; }
  }
  
  ```

  ```xml
  <!-- 定义Bean -->
  <bean id="myBean" class="pers.jeffy.spring5.factoryBean.MyBean"/>
  ```

  ```java
  // 测试案例
  @Test
  public void testCollection2(){
      ApplicationContext context = new ClassPathXmlApplicationContext("bean3.xml");
      // MyBean标签返回Courses对象
      Courses courses = context.getBean("myBean", Courses.class);
      System.out.println(courses);
  }
  ```

## 2.6 IOC操作Bean管理（Bean的作用域）

​	在Spring中，可以设置bean实例时单实例（对象获取多次为同一对象）还是多实例（每次获取对象都创建新对象），默认为单实例

```java
@Test
public void testCollection1(){
    ApplicationContext context = new ClassPathXmlApplicationContext("bean2.xml");
    Book book1 = context.getBean("book", Book.class);
    Book book2 = context.getBean("book", Book.class);
    System.out.println(book1); // pers.jeffy.spring5.collectiontype.Book@ae13544
    System.out.println(book2); // pers.jeffy.spring5.collectiontype.Book@ae13544
}
```

​	在Spring配置Bean文件的bean标签里有属性用来设置bean的作用域 -- scope<br/>		默认为 singleton 单实例<br/>		prototype 多实例

```xml
<bean id="book" class="pers.jeffy.spring5.collectiontype.Book" scope="prototype">
 	<property name="list" ref="bookList"/>
</bean>
```

```java
pers.jeffy.spring5.collectiontype.Book@ae13544
pers.jeffy.spring5.collectiontype.Book@3d34d211
```

​	singleton和prototype的区别<br/>		加载Spring配置文件时候就会创建单实例对象<br/>		prototype不在Spring加载配置文件时创建对象，而是在调用getBean方法时创建多实例对象

​	request、session

## 2.7 IOC操作Bean管理（Bean的生命周期）

### 1. 生命周期

​	从对象创建到销毁的过程

### 2.Bean的声名周期

1. 通过构造器创建bean实例（无参构造）
2. 为bean的属性设置值和对其他bean医用（调用set方法）
3. 调用bean的初始化方法（需要进行配置初始化方法）
4. bean可以使用（获取到对象）
5. 当容器关闭的时候，调用bean的销毁方法（需要手动配置销毁方法）

### 2.4 IOC操作Bean管理（基于注解）