## 2. Hadoop 序列化

### 2.1 序列化概述

#### 2.1.1 什么是序列化

​	序列化就是把内存中的对象，转换成字节序列（或其他数据传输协议）以便于存储到磁盘（持久化）和网络传输

​	反序列化就是将收到的子节序列（或其他数据传输协议）或者是磁盘的持久化数据，转换成内存中的对象

#### 2.1.2 为什么要序列化

​	一般的，“活的”对象只生存在内存里，关机断电就没有了。而且“活的”对象只能由本地的进程使用，不能被发送到网路上的另一台计算机。然而序列化可以存储“活的”对象，可以将“活的”对象发送到远程计算机。

#### 2.1.3 为什么不用Java的序列化

​	Java 的序列化是一个重量级的框架（Serializable），一个对象被序列化后，会附带很多额外的信息（校验信息，Header，继承体系等），不便于网络中高效传输。所以，Hadoop自己开发了一套序列化机制（Writable）

#### 2.1.4 Hadoop序列化特点

- 紧凑：高效使用存储空间
- 快速：读写数据的额外开销小
- 可扩展：随着通信协议的升级而可升级
- 互操作：支持多语言的交互

### 2.2 自定义Bean对象实现序列化接口（Writable）

1. 必须实现Writable接口

2. 反序列化时，需要反射调用无参构造函数，所以必须由无参构造

3. 重写序列化方法

4. 重写反序列化方法

   **注意：反序列化的顺序和序列化的顺序必须完全一致（队列）**

5. 要想把结果显示在文件中，需要重写toString()方法，可用"\t"分开，方便后续使用

6. 如果需要将自定义的bean放在key中传输，则还需要实现Comparable接口，因为MapReduce框中的Shuffle过程要求对key必须能排序。

### 2.3 序列化案例实操

#### 2.3.1 需求分析

1. 输入数据

   phone_data.txt

2. 输入数据格式

   | id   | 手机号      | ip           | 上行流量 | 下行流量 | 网络状态码 |
   | ---- | ----------- | ------------ | -------- | -------- | ---------- |
   | 1    | 13823478698 | 10.100.111.3 | 1111     | 22223    | 200        |

3. 期望数据格式

   | 手机号      | 上行流量 | 下行流量 |
   | ----------- | -------- | -------- |
   | 13823478698 | 1111     | 22223    |

4. Map阶段

   1. 读取一行数据，切分字段
   2. 抽取手机号、上行流量、下行流量
   3. 以手机号为key，bean对象为value输出及context.write（手机号.bean）
   4. bean对象要想能够传输，必须实现序列化接口

5. Reduce阶段

   1. 累加上行流量和下行流量求得总流量

#### 2.3.2  编写MapReduce程序