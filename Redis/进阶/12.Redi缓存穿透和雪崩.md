# 12.Redis缓存穿透和雪崩

## 12.1 概述

问题：

​	数据一致性问题：从严格意义上讲，这个问题是无解的。如果对数据一致性要求很高，那么就不能使用缓存

​	缓存穿透、缓存雪崩、缓存击穿 -- 这些都已有流行的解决方案

## 12.2 缓存穿透

​	当用户查询数据时，redis没有命中，则直接查询持久层数据库，如果持久层中也没有，则查询失败。当用户很多的时候，缓存都没有命中（如：秒杀），于是都去请求持久层数据库，那么就会对持久层数据库造成很大的压力。这种现象即为缓存穿透

### 12.2.1 布隆过滤器 Bloom Filter

​	布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力。

![image-20210407004108038](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210407004108038.png)

### 12.2.2 缓存空对象

​	当存储层不命中后，即使返回了空对象也对其进行缓存，同时设置一个过期时间，之后如果再访问则再缓存中获取，从而保护了后端数据库

![image-20210407004324163](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210407004324163.png)

问题：

	1. 如果空值能够被缓存起来，这就意味着需要更多的空间存储更多的键
	2. 即使对空值设置了过期时间，还是会存在缓存层和存储层会有一段时间窗口不一致，这对需要保持数据一致性的业务会有影响

## 12.3 缓存击穿

​	缓存击穿是指一个key非常热点，在不停的接收者大并发。在高并发的持续访问的情况下，在这个key失效的瞬间（如，缓存过期，需要查询数据库进行回写），则高并发会穿透缓存，直接请求数据库（就像一堵墙上被穿了一个洞）

### 12.3.1 设置热点数据永不过期

### 12.3.2 加互斥锁

分布式锁：使用分布式锁，保证对于每个key同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此只需要等待即可。

这种方式将高并发的压力转移到了分布式锁上，因此对分布式锁的压力会更大。

## 12.4 缓存雪崩

缓存雪崩，指在摸一个时间段内，缓存集中失效（如Redis服务器宕机）

产生原因，如：在写文本的时候，马上就要到双十一0点，很快就很迎来一波抢购，这波商品时间比较集中的放入了缓存。假如缓存失效的时间为一个小时，那么到了凌晨1点，这品商品的缓存全部失效，那么对于这批商品的查询就都落到了数据库上，对于数据库而言，就会差生周期性的压力波峰。由于是所有的请求都会到达存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。

缓存数据集中过期，是自然形成的雪崩，缓存服务器一定会在某个时间段集中创建缓存，这个时候，数据库也是可以顶住压力的，无非就是对服务器产生周期性的压力而已。而出现缓存服务器宕机的情况，对数据库产生的压力是不可预知的，有可能在短时间内将数据库压垮。

### 12.4.1 Redis高可用

异地多活、服务降级（关闭一些其他服务来保证热点服务的质量）

### 12.4.2 限量降级

在缓存失效后，通过加锁或者队列来控制读数据库写缓存的数量。比如对某个key只允许一个线程查询和写缓存，其他线程等待。

### 12.4.3 数据预热

数据预热的含义就是在正式部署之前，我们先把可能的数据预先访问一遍，着用部分可能大量访问数据就被加载到了缓存中。在即将发生的高并发的访问之前手动触发加载缓存的不同的key，同时设置不同的过期时间（生成随机过期时间），让缓存失效的时间尽量均匀。